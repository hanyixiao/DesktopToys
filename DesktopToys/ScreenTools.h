/*@fuction: unkown
 *@data: 2019-2-2
 *@author:YixiaoHan
  */
#pragma once
#include "stdafx.h"
class CScreenTools
{
private:
	CScreenTools()
	{

	}
	~CScreenTools()
	{

	}
private:
	//计算每个位图文件占用的字节数
	static int GetBits()
	{
		//显示当前分辨率下每个像素所占的字节数
		int iBits;
		HDC hDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
		iBits = GetDeviceCaps(hDC, BITSPIXEL)*GetDeviceCaps(hDC, PLANES);
		DeleteDC(hDC);
		return iBits;
	}
	//确定是多少位的位图
	static int GetBitCount(int iBits)
	{
		int wBitCount;
		if (iBits <= 1)
		{
			wBitCount = 1;
		}
		else if (iBits <= 4)
		{
			wBitCount = 4;
		}
		else if (iBits <= 8)
		{
			wBitCount = 8;
		}
		else if (iBits <= 24)
		{
			wBitCount = 24;
		}
		else {
			wBitCount = 32;
		}
		return wBitCount;
	}
	static BOOL WriteBmpDataToFile(PCTSTR szFileName,
		PBITMAPINFOHEADER pBitmapInfoHeader,
		DWORD dwPaletteSize, DWORD dwBmBitsSize)
	{
		//写入字节数
		DWORD dwWrite;
		HANDLE hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
			NULL);
		if (hFile == INVALID_HANDLE_VALUE) {
			return FALSE;
		}
		BITMAPFILEHEADER bitmapFileHeader;
		//设置位图文件头
		bitmapFileHeader.bfType = 0x4D42;//0x4d42即BM
		bitmapFileHeader.bfSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
			dwPaletteSize + dwBmBitsSize;
		bitmapFileHeader.bfReserved1 = 0;
		bitmapFileHeader.bfReserved2 = 0;
		bitmapFileHeader.bfOffBits= sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) +
			dwPaletteSize;
		//写入位图文件头
		WriteFile(hFile, (LPSTR)&bitmapFileHeader, sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)
			+ dwBmBitsSize + dwPaletteSize, &dwWrite, NULL);
		//关闭文件
		CloseHandle(hFile);
		return true;
	}
public:
	//保存到文件
	static int SaveBitmapToFile(HBITMAP hBitmap, LPCTSTR lpFileName)
	{
		/*bitmap文件格式如下
		 *BITMAPFILEHEADER
		 *BITMAPINFOHEADER
		 *RGBQUAD arry
		 *Color-index arry
		*/
		BOOL bRet = FALSE;
		//位图中每个像素所占的字节数
		WORD wBitCount;
		//定义调色板的大小，位图中像素的大小，位图文件大小和写入文件字节数
		DWORD dwPaletteSize = 0;
		DWORD dwBmBitSize;
		BITMAP Bitmap;
		BITMAPINFOHEADER bitmapInfoHeader;    //位图属性结构
		LPBITMAPINFOHEADER pBitmapInfoHeader; //位图信息结构
		wBitCount = GetBitCount(GetBits());   //确定多少位的位图
		if (wBitCount <= 8) {				  //计算调色板大小
			dwPaletteSize = (1 << wBitCount) * sizeof(RGBQUAD);
		}
		//设置位图信息头结构
		GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&Bitmap);
		bitmapInfoHeader.biSize = sizeof(BITMAPINFOHEADER);
		bitmapInfoHeader.biWidth = Bitmap.bmWidth;
		bitmapInfoHeader.biHeight = Bitmap.bmHeight;
		bitmapInfoHeader.biPlanes = 1;
		bitmapInfoHeader.biBitCount = wBitCount;
		bitmapInfoHeader.biCompression = BI_RGB;
		bitmapInfoHeader.biSizeImage = 0;
		bitmapInfoHeader.biXPelsPerMeter = 0;
		bitmapInfoHeader.biYPelsPerMeter = 0;
		bitmapInfoHeader.biClrUsed = 0;
		bitmapInfoHeader.biClrImportant = 0;
		//像素数据的大小
		//每一行的大小（必须是4的整数倍）
		dwBmBitSize = ((Bitmap.bmWidth*wBitCount + 31) / 32) * 4
			* Bitmap.bmHeight;
		HANDLE hDib = GlobalAlloc(GHND, dwBmBitSize + dwPaletteSize + sizeof(BITMAPINFOHEADER));
		pBitmapInfoHeader = (LPBITMAPINFOHEADER)GlobalLock(hDib);
		*pBitmapInfoHeader = bitmapInfoHeader;
		//获取调色板下新的像素值
		{
			HDC hDC;										  //设备描述表
			HPALETTE hOldPal = NULL;						  //获取旧的调色板
			hDC = ::GetDC(NULL);                              //获取屏幕DC
			HANDLE hPal = GetStockObject(DEFAULT_PALETTE);
			if (hPal) {
				hOldPal = SelectPalette(hDC, (HPALETTE)hPal, FALSE);
				RealizePalette(hDC);
			}
			//获取调色板下新的像素值
			GetDIBits(hDC, hBitmap, 0,
				(UINT)Bitmap.bmHeight,
				(LPSTR)pBitmapInfoHeader + sizeof(BITMAPINFOHEADER) +
				dwPaletteSize,
				(BITMAPINFO *)pBitmapInfoHeader,
				DIB_RGB_COLORS
			);
			if (hOldPal) {                                    //恢复调色板
				SelectPalette(hDC, hOldPal, TRUE);
				RealizePalette(hDC);
			}
			::ReleaseDC(NULL,hDC);
		}
		//创建位图的写入
		{
			if (!WriteBmpDataToFile(lpFileName, pBitmapInfoHeader, dwPaletteSize, dwBmBitSize))
			{
				goto _Cleanup;
			}
		}
		bRet = TRUE;
	_Cleanup:
		GlobalUnlock(hDib);
		GlobalFree(hDib);
		return bRet;
	}
	//获取位图句柄
	static HBITMAP CopyScreenToBitmap(LPRECT lpRect)
	{
		HDC hScrDC, hMemDC;
		HBITMAP  hBitmap, hOldBitmap;
		int nX, nY, nX2, nY2;
		int nWidth, nHeight;
		int xScrn, yScrn;
		if (IsRectEmpty(lpRect)) {
			return NULL;
		}
		hScrDC = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
		hMemDC = CreateCompatibleDC(hScrDC);//为屏幕创建设备描述表创建兼容的内存设备描述表
		//获取区域
		nX = lpRect->left;
		nY = lpRect->top;
		nX2 = lpRect->right;
		nY2 = lpRect->bottom;
		//获取屏幕分辨率
		xScrn = GetDeviceCaps(hScrDC, HORZRES);
		yScrn = GetDeviceCaps(hScrDC, VERTRES);
		//确保选定区域是可靠的
		if (nX < 0) {
			nX = 0;
		}
		if (nY < 0) {
			nY = 0;
		}
		if (nX2 > xScrn) {
			nX2 = xScrn;
		}
		if (nY2 > yScrn) {
			nY2 = yScrn;
		}
		nWidth = nX2 - nX;
		nHeight = nY2 - nY;
		//创建一个与屏幕设备描述表兼容的位图
		hBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight);
		hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap);
		BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY);
		//获取屏幕位图的句柄
		hBitmap = (HBITMAP)SelectObject(hMemDC, hOldBitmap);
		//清除
		DeleteDC(hScrDC);
		DeleteDC(hMemDC);
		//返回位图句柄
		return hBitmap;
	}
	//全屏截图
	static HBITMAP PrintScreen()
	{
		CRect rect;
		rect.left = 0;
		rect.top = 0;
		rect.right = GetSystemMetrics(SM_CXSCREEN);
		rect.bottom = GetSystemMetrics(SM_CYSCREEN);
		return CopyScreenToBitmap(rect);
	}
	//截取指定窗体
	static HBITMAP PrintWindow(HWND hwnd)
	{
		RECT rrrr;
		LPRECT lpRect= &rrrr;
		::GetWindowRect(hwnd, lpRect);
		HDC hScrDC, hMemDC;
		HBITMAP hBitmap, hOldBitmap;
		hScrDC = ::GetWindowDC(hwnd);
		hMemDC = CreateCompatibleDC(hScrDC);
		int nWidth = lpRect->right - lpRect->left;
		int nHeight = lpRect->bottom - lpRect->top;
		//创建一个与屏幕设备描述表兼容的位图
		hBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight);
		//把新的内容选到设备描述表中
		hOldBitmap = (HBITMAP)SelectObject(hScrDC, hBitmap);
		//把屏幕的设备描述表复制到内存描述表中
		BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, 0, 0, SRCCOPY);
		hBitmap = (HBITMAP)SelectObject(hMemDC, hOldBitmap);
		DeleteDC(hScrDC);
		DeleteDC(hMemDC);
		return hBitmap;
	}
	static void DrawMouse(POINT pnt)
	{
		HWND DeskHwnd = ::GetDesktopWindow();             //获取桌面句柄
		HDC DeskDC = ::GetWindowDC(DeskHwnd);             //获取桌面设备句柄
		int oldRop2 = SetROP2(DeskDC, R2_NOTXORPEN);      
		HPEN newPen = ::CreatePen(0, 1, RGB(255, 0, 0));  //建立新画柄，载入DeskDC
		HGDIOBJ oldPen = ::SelectObject(DeskDC, newPen);  //选定画柄，并保存旧的画柄
		::MoveToEx(DeskDC, pnt.x - 10, pnt.y, NULL);      //在窗口四周画一个方框
		::LineTo(DeskDC, pnt.x + 10, pnt.y);
		::MoveToEx(DeskDC, pnt.x, pnt.y + 10, NULL);
		::LineTo(DeskDC, pnt.x, pnt.y - 10);
		::SetROP2(DeskDC, oldRop2);                    
		::SelectObject(DeskDC, oldPen);                   //恢复为旧画柄
		::DeleteObject(newPen);
		::ReleaseDC(DeskHwnd, DeskDC);
		DeskDC = NULL;
	}
};